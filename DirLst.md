Vanilla JS로 프론트엔드 구조를 잡을 때도, 백엔드에서 사용한 레이어드 아키텍처의 개념을 어느 정도 반영할 수 있습니다. 다만 프론트엔드는 화면 렌더링과 DOM 조작이 중심이 되므로, 백엔드 구조와 정확히 동일하게 가져가는 것보다는 실제 사용 시 편리함을 고려해서 약간 변형된 디렉토리 체계를 권장합니다. 아래는 예시 구조입니다:

arduino
복사
편집
├─ index.html              // 메인 HTML 파일
├─ assets/                // 이미지, 폰트, 아이콘 등 정적 자원
│   ├─ images/
│   └─ fonts/
├─ css/
│   └─ style.css          // 전역 스타일 시트
└─ js/
    ├─ config/            // 프론트엔드 전역 설정, 라우팅, 상수
    │   └─ router.js
    ├─ controllers/       // 페이지별(혹은 컴포넌트별) 이벤트 처리, DOM 조작 로직
    │   └─ userController.js
    ├─ dto/               // (옵션) 서버와 주고받는 데이터 구조 정의
    │   └─ userDto.js
    ├─ exceptions/        // 클라이언트 측에서 발생하는 예외 처리 (Custom Error 등)
    │   └─ customError.js
    ├─ helpers/           // 범용 유틸/도우미 함수 (DOM 헬퍼, 공통 함수 등)
    │   └─ domHelper.js
    ├─ models/            // (옵션) 프론트에서 다루는 도메인 모델(상태) 객체 정의
    │   └─ user.js
    ├─ repositories/      // (옵션) Fetch/Ajax 통신, API 호출 로직
    │   └─ userRepository.js
    ├─ services/          // 비즈니스 로직(화면 단에서 처리되는 로직) 
    │   └─ userService.js
    └─ validators/        // 입력값 검증 로직 (폼 검증 등)
        └─ userValidator.js
아래에서 각 디렉토리별 역할을 보다 자세히 살펴보겠습니다.

1. index.html
실제 브라우저가 불러들이는 메인 HTML 파일.

필요한 JS 스크립트와 CSS를 로드하며, 화면의 “뼈대” 역할을 담당.

2. assets/
이미지, 폰트, 아이콘 등 프로젝트 내 정적(Static) 리소스를 모아둔다.

일반적으로 웹팩 등 빌드 도구를 사용하면 번들링하거나 최적화 작업(이미지 스프라이트, 웹 폰트 등)을 수행할 수 있다.

3. css/
전역 스타일 시트나 전역 변수(CSS 변수, reset.css 등)를 담아두는 디렉토리.

프로젝트가 커지면 컴포넌트별 CSS 또는 SCSS로 나누기도 하며, 프리프로세서(SASS, LESS)를 쓰는 경우 구조가 달라질 수 있다.

4. js/config/
프론트엔드의 전역 설정이나 라우팅을 담당.

예:

페이지별 해시 라우팅(router.js)

API 엔드포인트 상수(const API_BASE_URL = "...";)

글로벌로 필요한 설정(테마, 인증 관련 상수)

네이티브 바닐라 JS로 라우팅을 직접 구현하거나, location.hash를 활용한 간단한 라우터 로직을 넣을 수 있다.

5. js/controllers/
실제 화면(또는 DOM)과 직접 상호작용하는 이벤트 처리 로직이 들어간다.

흔히 MVC 모델에서 Controller가 하는 역할과 유사:

특정 버튼 클릭, 폼 제출 등의 이벤트를 감지하고,

Service(또는 Repository) 로직을 호출해서 데이터를 가져오거나,

가져온 데이터를 DOM에 렌더링.

예: userController.js는 로그인/회원가입 폼 이벤트를 처리하고, 가입 요청 전송 후 성공/실패 결과에 따른 화면 상태 변경 등을 담당.

6. js/dto/ (옵션)
서버와의 통신에서 Request/Response에 필요한 데이터 구조를 정의할 때 사용.

백엔드에서 사용하는 DTO 개념을 프론트에서도 일관성 있게 적용하려면, 서버에 전송하거나 서버로부터 받는 JSON 구조를 명시해두면 좋다.

아주 간단한 애플리케이션이라면 굳이 DTO를 세분화하지 않고, 바로 자바스크립트 객체를 전달해도 된다.

7. js/exceptions/
클라이언트 사이드에서 발생하는 예외를 Custom Error 객체로 정의하거나, 중앙에서 예외를 처리하는 로직을 두는 디렉토리.

브라우저 단에서도 네트워크 에러, 파싱 에러 등 다양한 예외가 발생할 수 있고, 이러한 예외를 식별하고 처리(에러 메시지 표시, 로그 전송 등)할 필요가 있다.

8. js/helpers/
DOM 조작(예: getElementById, querySelector 등 래핑), 날짜 포매팅, 문자열 변환, 쿠키/로컬스토리지 접근 등 범용 유틸 함수를 모아둔다.

프로젝트 곳곳에서 필요로 하는 공통 기능을 한 곳에 정리해두어 중복을 방지하고, 유지보수를 용이하게 만든다.

9. js/models/ (옵션)
프론트엔드에서 상태나 도메인 객체를 보다 명확히 관리하고 싶을 때 사용.

예: User 모델 클래스에 유효성 검증 로직이나, 상태 변경 시 필요한 메서드를 넣을 수 있다.

간단한 스크립트로 구성된 프로젝트라면 모델을 따로 분리하지 않고 Service나 Controller에서 객체를 직접 생성/관리하기도 한다.

10. js/repositories/ (옵션)
데이터 통신(네트워크 요청) 로직을 한 곳에 모아둠으로써, API 호출/에러 처리/응답 파싱 등을 통합 관리한다.

예: userRepository.js에서 fetch 혹은 XMLHttpRequest 등을 통해 REST API 호출을 처리하며, JSON을 받아 파싱해 반환.

이렇게 분리해두면, Service 레이어에서 Repository를 호출하여 데이터만 받아오도록 단순화할 수 있다.

11. js/services/
비즈니스 로직을 담는 레이어로, Controller와 Repository 사이에서 실제 데이터 가공이나 추가 검증, 비즈니스 규칙 등을 처리.

예: userService.js에서는 로그인, 회원가입, 비밀번호 변경 등 로직을 제공.

입력값을 검증(Validator 활용)

Repository로부터 필요한 데이터를 가져오거나 서버에 저장

결과값을 Controller에 반환

12. js/validators/
입력값 검증 로직이 복잡하거나, 여러 화면에서 공통으로 검증해야 하는 로직이 많은 경우 분리.

일반적인 폼 검증(이메일 형식, 비밀번호 정책, 전화번호 형식 등)을 validator 파일로 모듈화하면 좋다.

예: userValidator.js에서 회원가입 폼(이메일, 비밀번호, 이름 등)을 검증하고, 실패 시 특정 에러 메시지를 반환하도록 한다.

정리
Vanilla JS로 프론트엔드를 작성할 때도, 백엔드(스프링)에서 쓰는 레이어드 아키텍처를 일부 차용할 수 있습니다.

다만 프론트엔드 특성상 DOM 조작과 UI 렌더링이 크고, 각종 이벤트 처리와 네트워크 통신이 중심이 되므로, 위 예시에서처럼 Controller/Service/Repository와 Helper, Validator 등으로 나누는 방식을 추천합니다.

실제 프로젝트 요구사항이나 팀의 코드 스타일에 따라 폴더 명은 달라질 수 있으나, 역할과 책임을 분리하면 협업과 유지보수에 큰 이점을 얻게 됩니다.